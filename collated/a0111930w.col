//@author: a0111930w



	/**
	 * origin: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\Action.java
	 */

    public void setIsCommandType(boolean isCommand) {
        this._isCommandType = isCommand;
    }

	// End of segment: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\Action.java





	/**
	 * origin: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\Action.java
	 */

    public boolean getIsCommandType() {
        return this._isCommandType;
    }

	// End of segment: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\Action.java





	/**
	 * origin: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\Action.java
	 */

    public void setInvalidCommandType(Settings.CommandType invalidType) {
        this._invalidCommandType = invalidType;
    }

	// End of segment: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\Action.java





	/**
	 * origin: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\Action.java
	 */

    public Settings.CommandType getInvalidCommandType() {
        return this._invalidCommandType;
    }

    public String toString() {
        String stringToReturn = _commandType.toString();

        if (_task != null) {
            stringToReturn += " " + String.valueOf(_task.getTaskId()) + " "
                    + _task.getDescription();
        }
        if (_negateAction != null) {
            stringToReturn += " [negation " + _negateAction.getCommandType()
                    + " " + String.valueOf(_negateAction.getTask().getTaskId())
                    + "]";
        }
        return stringToReturn;
    }

    public boolean equals(Object o) {
        if (o instanceof Action) {
            Action a = (Action) o;
            return this.getCommandType().equals(a.getCommandType())
                    && this.getTask() == null
                    && a.getTask() == null
                    || (this.getTask() != null && a.getTask() != null
                            && this.getTask().equals(a.getTask()) && this
                            .getTask().getDescription()
                            .equals(a.getTask().getDescription()));
        } else {
            return false;
        }
    }

    public String getUserInput() {
        return _userInput;
    }

    public void setUserInput(String userInput) {
        _userInput = userInput;
    }
}

	// End of segment: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\Action.java





	/**
	 * origin: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\DisplayView.java
	 */

package chirptask.logic;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Collections;
import java.util.List;

import javafx.scene.text.Text;
import javafx.scene.text.TextFlow;
import chirptask.common.Constants;
import chirptask.common.Settings;
import chirptask.common.Settings.CommandType;
import chirptask.common.Settings.StatusType;
import chirptask.gui.MainGui;
import chirptask.storage.DeadlineTask;
import chirptask.storage.Task;
import chirptask.storage.TimedTask;

/**
 * This class handles the processing of filtertask before displaying the results
 * to user
 * using MainGui methods.
 * 
 *
 */

public class DisplayView {
    private static final int START_LIST = 0;

    /**
     * This will take in a filtered list and update the taskview, sort to
     * date/time, store into List of tasks
     * 
     * @param tasks
     *            The list of filtered tasks
     * @param gui
     *            The MainGui object to manipulate
     */
    public static void updateTaskView(List<Task> tasks, MainGui gui) {

        sortTask(tasks);
        processUpdateTaskView(tasks, gui);
        processUpdateHashtagAndCategoryView(gui);

    }

    /**
     * Method will sort the task
     * 
     * @param tasks
     *            The list of tasks to sort
     */
    private static void sortTask(List<Task> tasks) {
        Collections.sort(tasks);
    }

    /**
     * This method will update the Context and category on the GUI
     * 
     * 
     * @param gui
     *            The MainGui object to manipulate
     */
    private static void processUpdateHashtagAndCategoryView(MainGui gui) {
        updateCategoryView(gui);
        updateHashtagView(gui);
    }

    /**
     * This method will update the user GUI view. The GUI view will be sorted to
     * all tasks under a date.
     * 
     * 
     * @param tasks
     *            The list of tasks to loop through
     * @param gui
     *            The MainGui object to manipulate
     */
    private synchronized static void processUpdateTaskView(List<Task> tasks,
            MainGui gui) {
        for (int i = START_LIST; i < tasks.size(); i++) {
            Task T = tasks.get(i);
            updateTaskViewDate(gui, T);
            String dateToString = convertTaskDateToDurationString(T);
            updateTaskToDate(gui, T, dateToString);
        }

    }

    /**
     * Method will call GUI method to update the task under the respective date
     * 
     * @param gui
     *            The MainGui object to manipulate
     * @param T
     *            The Task to update in GUI
     * @param dateToString
     *            The date String to update in GUI
     */
    private static void updateTaskToDate(MainGui gui, Task T,
            String dateToString) {
        gui.addNewTaskViewToDate(T.getDate(), T.getTaskId(),
                T.getDescription(), dateToString, T.isDone());
    }

    /**
     * Method will call GUI method to create a date view
     * 
     * @param gui
     *            The MainGui object to manipulate
     * @param T
     *            The Task to add the date to GUI
     */
    private static void updateTaskViewDate(MainGui gui, Task T) {
        gui.addNewTaskViewDate(T.getDate());
    }

	// End of segment: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\DisplayView.java





	/**
	 * origin: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\DisplayView.java
	 */

    /**
     * This method will be call during init to display all task
     * 
     * @param gui
     *            The MainGui object to manipulate
     */
    public static void updateTaskView(MainGui gui) {
        List<Task> allTasks = FilterTasks.getFilteredList();
        if (allTasks != null) {
            updateTaskView(allTasks, gui);
        }

    }

    /**
     * This method will call gui to update the category view.
     * 
     * @param gui
     *            The MainGui object to manipulate
     */
    public static void updateCategoryView(MainGui gui) {
        List<String> categories = FilterTasks.getCategoryList();
        for (String category : categories) {
            gui.addCategoryIntoList(category);
        }
    }

    /**
     * This method will call gui to update the Hashtag view.
     * 
     * @param gui
     *            The MainGui object to manipulate
     */
    public static void updateHashtagView(MainGui gui) {
        List<String> contexts = FilterTasks.getContextList();
        for (String context : contexts) {
            gui.addHashtagIntoList(context);
        }
    }

    /**
     * Show status to user with the respective message
     * 
     * @param Message
     *            The status message to update
     * @param gui
     *            The MainGui object to manipulate
     */
    public static void showStatusToUser(String Message, MainGui gui) {
        gui.setStatus(Message);
    }

    /**
     * Show status to user depending on the success
     * 
     * @param Message
     *            The status message to update
     * @param gui
     *            The MainGui object to manipulate
     * @param success
     *            The flag of whether it is successful or not
     */
    public static void showStatusToUser(String Message, MainGui gui,
            boolean success) {
        if (success) {
            gui.setStatus(Message);
        } else {
            gui.setError(Message);
        }
    }

    /**
     * Show status to user depending on the execution of display command
     * 
     * @param type
     *            The StatusType to update on GUI
     * @param gui
     *            The MainGui object to manipulate
     * @param filter
     *            The filters applied
     */
    public static void showStatusToUser(Settings.StatusType type, MainGui gui,
            String filter) {
        if (isStatusError(type)) {
            processGUIError(gui, Constants.LOG_MESSAGE_DISPLAY_USAGE,
                    Constants.LOG_MESSAGE_ERROR, "");
        } else {
            processGUIError(gui, Constants.LOG_MESSAGE_DISPLAY,
                    Constants.LOG_MESSAGE_SUCCESS, filter);
        }
    }

    /**
     * This method will show the status result to user after each action user
     * input.
     * 
     * 
     * @param type
     *            The StatusType to update on GUI
     * @param action
     *            The Action that was being processed
     * @param gui
     *            The MainGui object to manipulate
     * 
     * 
     */
    public static void showStatusToUser(Settings.StatusType type,
            Action action, MainGui gui) {
        CommandType command = action.getCommandType();
        if (isStatusError(type)) {
            processErrorGui(action, gui, command);
        } else {
            processSuccessGui(action, gui, command);
        }
    }

    /**
     * Method will display success message to user
     * 
     * @param action
     *            The Action that was being processed
     * @param gui
     *            The MainGui object to manipulate
     * @param command
     *            The CommandType to process
     */
    private static void processSuccessGui(Action action, MainGui gui,
            CommandType command) {
        switch (command) {
            case ADD :
                processGUI(action, gui, Constants.LOG_MESSAGE_ADD_TASK,
                        Constants.LOG_MESSAGE_SUCCESS);

                break;
            case DELETE :
                processGUI(action, gui, Constants.LOG_MESSAGE_REMOVE_TASK,
                        Constants.LOG_MESSAGE_SUCCESS);
                break;

            case EDIT :
                processGUI(action, gui, Constants.LOG_MESSAGE_MODIFY_TASK,
                        Constants.LOG_MESSAGE_SUCCESS);

                break;
            case DONE :
                processGUI(action, gui, Constants.LOG_MESSAGE_DONE,
                        Constants.LOG_MESSAGE_SUCCESS);

                break;
            case UNDONE :
                processGUI(action, gui, Constants.LOG_MESSAGE_MODIFY_TASK,
                        Constants.LOG_MESSAGE_SUCCESS);
                break;
            case LOGIN :
                processGuiLogin(gui, Constants.LOG_MESSAGE_LOGIN, true,
                        Constants.LOG_MESSAGE_SUCCESS);
                break;
            case LOGOUT :
                processGuiLogin(gui, Constants.LOG_MESSAGE_LOGOUT_SUCCESS,
                        true, "");
                break;
            case DISPLAY :
                processGUI(action, gui, Constants.LOG_MESSAGE_DISPLAY,
                        Constants.LOG_MESSAGE_SUCCESS);
                break;
            case SYNC :
                processGuiLogin(gui, Constants.LOG_MESSAGE_SYNC, true,
                        Constants.LOG_MESSAGE_SYN_INIT);
                break;
            default:
                assert false;
                break;
        }
    }

    /**
     * Method will display error message to user
     * 
     * @param action
     *            The Action to process
     * @param gui
     *            The MainGui object to manipulate
     * @param command
     *            The CommandType to process
     */
    private static void processErrorGui(Action action, MainGui gui,
            CommandType command) {
        switch (command) {
            case ADD :
                processGUI(action, gui, Constants.LOG_MESSAGE_ADD_TASK,
                        Constants.LOG_MESSAGE_ERROR);
                break;
            case DELETE :
                processGUI(action, gui, Constants.LOG_MESSAGE_REMOVE_TASK,
                        Constants.LOG_MESSAGE_ERROR);
                break;

            case EDIT :
                processGUI(action, gui, Constants.LOG_MESSAGE_MODIFY_TASK,
                        Constants.LOG_MESSAGE_ERROR);

                break;
            case DONE :
                processGUI(action, gui, Constants.LOG_MESSAGE_DONE,
                        Constants.LOG_MESSAGE_ERROR);
                break;
            case UNDONE :
                processGUI(action, gui, Constants.LOG_MESSAGE_MODIFY_TASK,
                        Constants.LOG_MESSAGE_ERROR);
                break;
            case LOGIN :
                processGuiLogin(gui, Constants.LOG_MESSAGE_LOGIN, false,
                        Constants.LOG_MESSAGE_ERROR);
                break;
            case SYNC :
                processGuiLogin(gui, Constants.LOG_MESSAGE_SYNC_FAIL, false,
                        Constants.LOG_MESSAGE_FAIL);
                break;
            case LOGOUT :
                processGuiLogin(gui, Constants.LOG_MESSAGE_LOGOUT_FAIL, false,
                        "");
                break;
            default:
                processGUIError(gui, Constants.LOG_MESSAGE_INVALID_COMMAND,
                        Constants.LOG_MESSAGE_ERROR, "");
                break;
        }
    }

    /**
     * Return true if statustype is error, else return true
     * 
     * @param type
     *            The StatusType to compare
     * @return True if error, false otherwise
     */
    private static boolean isStatusError(Settings.StatusType type) {
        return type == Settings.StatusType.ERROR;
    }

    /**
     * This method will process the show the user error when a wrong command is
     * input.
     * 
     * 
     * @param action
     *            The Action to process
     * @param gui
     *            The MainGui object to manipulate
     * @param logMessageInvalidCommand
     *            The message to log
     * @param logMessageError
     *            The message to log
     */
    private static void processGUIError(MainGui gui,
            String logMessageInvalidCommand, String logMessageError,
            String filter) {
        if (isLogMessageError(logMessageError)) {
            gui.setError(String.format(logMessageInvalidCommand));
        } else {
            gui.setStatus(String.format(logMessageInvalidCommand,
                    logMessageError, filter));
        }
    }

    /**
     * Method will return true is is a error message, else false
     * 
     * @param logMessageError
     *            The message to log
     * @return True if error, false otherwise
     */
    private static boolean isLogMessageError(String logMessageError) {
        return logMessageError == Constants.LOG_MESSAGE_ERROR;
    }

    /**
     * This method will show the failure or success of login to user.
     * 
     * @param gui
     *            The MainGui object to manipulate
     * @param message
     *            The message to display
     * @param result
     *            The result to display
     */
    private static void processGuiLogin(MainGui gui, String message,
            Boolean isSuccess, String result) {
        if (isSuccess) {
            gui.setStatus(String.format(message, result));
        } else {
            gui.setError(String.format(message, result));
        }
    }

    /**
     * This method will show the failure or success for simple
     * add/delete/done/undone/login/display
     * 
     * @param action
     *            The Action to process
     * @param gui
     *            The MainGui object to manipulate
     * @param message
     *            The message to display
     * @param result
     *            The result to display
     */
    private static void processGUI(Action action, MainGui gui, String message,
            String result) {
        if (result.equalsIgnoreCase(Constants.LOG_MESSAGE_SUCCESS)) {
            gui.setStatus(String.format(message, result, action.getTask()
                    .getDescription()));
        } else {
            gui.setError(String.format(message, result, action.getTask()
                    .getDescription()));
        }
    }

	// End of segment: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\DisplayView.java





	/**
	 * origin: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\DisplayView.java
	 */

    /**
     * Show message and command type to user.
     * 
     * @param message
     *            The message to display
     * @param type
     *            The CommandType to display
     * @param _gui
     *            The MainGui object to manipulate
     */
    public static void showStatusToUser(StatusType message, CommandType type,
            MainGui _gui) {
        assert _gui != null;
        processGUI(message, type, _gui);
    }

    /**
     * Method will call gui and show status to user
     * 
     * @param message
     *            The StatusType to process
     * @param type
     *            The CommandType to process
     * @param _gui
     *            The MainGui object to manipulate
     */

    private static void processGUI(StatusType message, CommandType type,
            MainGui _gui) {
        assert _gui != null;
        if (isStatusError(message)) {

            _gui.setError(formatStringError(type));
        } else {

            _gui.setStatus(formatStringSuccess(type));
        }

    }

    /**
     * Format the success message
     * 
     * @param type
     *            The CommandType to process
     * @return The formatted success string
     */
    private static String formatStringSuccess(CommandType type) {
        return String.format(Constants.LOG_MESSAGE_SUCCESS_OR_FAILURE,
                Constants.LOG_MESSAGE_SUCCESS, type.toString());
    }

    /**
     * Format the error message
     * 
     * @param type
     *            The CommandType to process
     * @return The formatted error string
     */
    private static String formatStringError(CommandType type) {
        return String.format(Constants.LOG_MESSAGE_SUCCESS_OR_FAILURE,
                Constants.LOG_MESSAGE_FAIL, type.toString());
    }
}

	// End of segment: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\DisplayView.java





	/**
	 * origin: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\FilterTasks.java
	 */


package chirptask.logic;

import java.security.InvalidParameterException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

import chirptask.common.Constants;
import chirptask.common.Settings;
import chirptask.common.Settings.StatusType;
import chirptask.gui.MainGui;
import chirptask.storage.StorageHandler;
import chirptask.storage.Task;

/**
 * This class is use to populate the task/hashtag/category list and will be use to display
 * by DisplayView class.
 * 
 * 
 *
 */
public class FilterTasks {

    private static List<Task> filteredTask;
    private static List<String> categoriesList;
    private static List<String> hashtagList;
    private static String currentFilter = Settings.DEFAULT_FILTER;
    private static final int INIT_FILTER = 1;
    private static final int INIT_TASKINDEX = -1;
    private static final int ZERO_POS = 0;
    private static final int FIRST_POS = 1;
    private static final int START_INDEX = 0;
    private static final int INT_ONE = 1;
    private static final String SPACE = "\\s+";
    private static final String SLASH = "/";
    private static final String EDIT = "edit ";
    /**
     * This method is use to process the current filter entered by user
     * 
     * @param T The Task containing the filter string
     * @param gui The MainGui object to manipulate
     */
    public static void filter(Task T, MainGui gui) {
        filteredTask = StorageHandler.getAllTasks();
        filteredTask = hideDeleted(filteredTask);
        currentFilter = T.getDescription();
        if (currentFilter.isEmpty()) {
            showStatusToUser(gui);
        } else {
            processFilter(currentFilter, gui);
        }

    }

    /**
     * Show appropriate message to user
     * 
     * @param gui The MainGui object to manipulate
     */
    private static void showStatusToUser(MainGui gui) {
        DisplayView.showStatusToUser(StatusType.MESSAGE, gui, "");
    }

    /**
     * Enables gui component to call this method when user presses tab to show
     * the edited description
     * 
     * @param editInput The user input to search for index number
     * @param gui The MainGui object to manipulate
     */
    public static void editCli(String editInput, MainGui gui) {
        assert gui != null && !editInput.trim().isEmpty();
        int taskIndex = convertInputToIndex(editInput);
        showEditTaskToUser(gui, taskIndex);
    }

    /**
     * Check if edited task is in the task list range and show the selected task
     * to cli.
     * 
     * @param gui The MainGui object to manipulate
     * @param taskIndex The task index to grab information from
     */
    private static void showEditTaskToUser(MainGui gui, int taskIndex) {
        int oldtaskIndex = taskIndex;
        taskIndex--;
        if (isTaskIndexInRange(taskIndex)) {
            showEditTask(gui, taskIndex, oldtaskIndex);
        }
    }

    private static void showEditTask(MainGui gui, int taskIndex,
            int oldtaskIndex) {
        gui.setUserInputText(EDIT + oldtaskIndex + " "
                + filteredTask.get(taskIndex).getDescription());
    }

    /**
     * Method returns true if task key in by user is within the range of the
     * displayed task.
     * 
     * @param taskIndex The task index to check if in range
     * @return true if in range, false otherwise
     */
    private static boolean isTaskIndexInRange(int taskIndex) {
        return taskIndex > INIT_TASKINDEX && taskIndex < filteredTask.size();
    }

    private static int convertInputToIndex(String editInput) {
        int taskIndex = INIT_TASKINDEX;
        try {
            taskIndex = Integer.parseInt(editInput.split(" ")[FIRST_POS]);
        } catch (NumberFormatException e) {
            // update status bar if required
        } catch (ArrayIndexOutOfBoundsException e) {
            // update status bar if required
        }
        return taskIndex;
    }

    /**
     * Return a list of tasks that is not deleted.
     * 
     * @param taskList The List of Task objects to hide
     * @return The List of Task without all the isDeleted=true Task
     */
    public static List<Task> hideDeleted(List<Task> taskList) {
        List<Task> unhiddenList = new ArrayList<Task>();

        for (int i = START_INDEX; i < taskList.size(); i++) {
            Task currTask = taskList.get(i);
            if (!currTask.isDeleted()) {
                unhiddenList.add(currTask);
            }
        }

        return unhiddenList;
    }

    /**
     * Process the user input for filter and populate the list of tasks
     * accordingly
     * 
     * @param filters The String containing all filters
     * @param gui The MainGui object to manipulate
     */
    private static void processFilter(String filters, MainGui gui) {
        String[] param = processFilterInput(filters);

        List<Task> processList = new CopyOnWriteArrayList<Task>();
        processList.addAll(filteredTask);

        for (int paramPos = START_INDEX; paramPos < param.length; paramPos++) {
            String filter = param[paramPos];
            paramPos = determineFilterAndExecute(gui, param, processList, paramPos, filter);
            filteredTask = new ArrayList<Task>(processList);
        }

    }

    private static int determineFilterAndExecute(MainGui gui, String[] param,
            List<Task> templist, int pos, String filter) {
        switch (filter) {
        case Settings.FILTER_DONE:
            filterStatus(templist, true);
            break;
        case Settings.FILTER_UNDONE:
            filterStatus(templist, false);
            break;
        case Settings.FILTER_FLOATING:
            filterTaskType(templist, Task.TASK_FLOATING);
            break;
        case Settings.FILTER_TIMED:
            filterTaskType(templist, Task.TASK_TIMED);
            break;
        case Settings.FILTER_DEADLINE:
            filterTaskType(templist, Task.TASK_DEADLINE);
            break;
        case Settings.FILTER_DATE:
            filterTaskDate(gui, param, templist, pos);
            pos++;
            break;
        default:
            filterKeyword(templist, filter);
            break;
        }
        return pos;
    }

    /**
     * Filter the task list by date
     * 
     * @param gui The MainGui object to manipulate
     * @param param The filter date parameters 
     * @param templist The filtered List to manipulate
     * @param index The index of filter in param
     */
    private static void filterTaskDate(MainGui gui, String[] param,
            List<Task> templist, int index) {
        try {
            Calendar filterdate = processFilterDateParam(param[index + INIT_FILTER]);
            if (filterdate != null) {
                processFilterDate(gui, param, templist, index, filterdate);
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            templist = processExceptionLogging(gui);

        } catch (InvalidParameterException invalidParameterException) {
            DisplayView.showStatusToUser(StatusType.ERROR, gui, "");
        }
    }

    /**
     * Process the date filter and display status to user
     * 
     * @param gui The MainGui object to manipulate
     * @param param The filter data parameters
     * @param templist The filtered List to manipulate
     * @param i The index of filter in param
     * @param filterdate The Calendar Date object to filter by and on
     */
    private static void processFilterDate(MainGui gui, String[] param,
            List<Task> templist, int i, Calendar filterdate) {
        // add 1 so that the filter includes tasks of the
        // same date.
        filterdate.add(Calendar.DAY_OF_MONTH, 1);
        filterTaskByDate(templist, filterdate);
        DisplayView.showStatusToUser(StatusType.MESSAGE, gui, param[i
                + INIT_FILTER]);
    }

    /**
     * Log down invalid action by user and set error status.
     * 
     * @param gui The MainGui object to manipulate
     * @return The List of Task containing all Session tasks
     */
    private static List<Task> processExceptionLogging(MainGui gui) {
        List<Task> templist;
        StorageHandler.logError(Constants.LOG_MESSAGE_INVALID_COMMAND);
        DisplayView.showStatusToUser(StatusType.ERROR, gui, "");

        templist = new ArrayList<Task>(StorageHandler.getAllTasks());
        return templist;
    }

    /**
     * Method that will split the filter string by space
     * 
     * @param filters
     * @return
     */
    private static String[] processFilterInput(String filters) {
        return filters.split(SPACE);
    }

    /**
     * Process the user date input and return an calendar object
     * 
     * @param filter The filter date String 
     * @return The Calendar object that was parsed from filter string
     * @throws InvalidParameterException If user did not enter ##/##
     */
    public static Calendar processFilterDateParam(String filter)
            throws InvalidParameterException {
        String[] temp = filter.split(SLASH);
        Calendar filterdate = Calendar.getInstance();
        if (isValidDateLength(temp)) {
            try {
                setCalendar(temp, filterdate);
            } catch (NumberFormatException e) {

            }
        } else {
            // Exception should handle here show status to user
            throw new InvalidParameterException();
        }

        return filterdate;
    }

    /**
     * 
     * @param temp The temp split date array [dd/mm]
     * @param filterdate The Calendar object to manipulate
     */
    private static void setCalendar(String[] temp, Calendar filterdate) {
        filterdate.set(filterdate.get(Calendar.YEAR),
                convertStringDateToInt(temp, FIRST_POS) - INT_ONE,
                convertStringDateToInt(temp, ZERO_POS));
    }

    private static int convertStringDateToInt(String[] temp, int pos) {
        return Integer.parseInt(temp[pos]);
    }

    private static boolean isValidDateLength(String[] temp) {
        return temp.length > INT_ONE;
    }

    private static void filterTaskByDate(List<Task> tempList,
            Calendar filterdate) {
        populateDateList(tempList, filterdate);
        if (tempList.isEmpty()) {
            resetFilteredTask();
            populateDateList(tempList, filterdate);
        }
    }

    /**
     * This method will check the filter date with the list of
     * fliteredtask if the filter date is after and equals to the
     * Task date add to the list.
     * 
     * @param tempList The List of current Task
     * @param filterdate The date to filter by and on.
     */

    private static void populateDateList(List<Task> tempList,
            Calendar filterdate) {
        for (Task T : filteredTask) {
            if (filterdate.compareTo(T.getDate()) < INT_ONE) {
                tempList.remove(T);
            }
        }

    }

    private static void filterKeyword(List<Task> tempList, String keyword) {
        populateStringList(tempList, keyword);
        if (tempList.isEmpty()) {
            resetFilteredTask();
            populateStringList(tempList, keyword);
        }
    }
    /**
     * This method will remove from all the tasks that does not match the user input,
     * final filteredTask list will contains all tasks that matches. 
     * 
     * @param templist The current working List to filter
     * @param keywords The keywords to search for
     */
    private static void populateStringList(List<Task> templist, String keywords) {
        for (Task T : filteredTask) {
            if (!T.getDescription().toLowerCase()
                    .contains(keywords.toLowerCase())) {
                templist.remove(T);
            }
        }
    }

    private static void filterStatus(List<Task> tempList, boolean done) {
        populateStatusList(tempList, done);
        if (tempList.isEmpty()) {
            resetFilteredTask();
            populateStatusList(tempList, done);
        }
    }
    /**
     * 
     * @param tempList The current List of Task
     * @param done If true filter all done task, else filter all undone task
     */
    private static void populateStatusList(List<Task> tempList, boolean done) {
        for (Task T : filteredTask) {
            if (T.isDone() != done) {
                tempList.remove(T);
            }
        }
    }
    /**
     * Repopulate the filtered task which simulate a refresh.
     */
    private static void resetFilteredTask() {
        filteredTask = StorageHandler.getAllTasks();
        filteredTask = hideDeleted(filteredTask);
    }

    private static void filterTaskType(List<Task> tempList, String taskType) {
        populateTaskList(tempList, taskType);
        if (filteredTask.isEmpty()) {
            resetFilteredTask();
            populateTaskList(tempList, taskType);
        }
    }

    private static void populateTaskList(List<Task> tempList, String taskType) {
        for (Task T : filteredTask) {
            if (!T.getType().equalsIgnoreCase(taskType)) {
                tempList.remove(T);
            }
        }
    }
    /**
     * This will populate all task and category/hastags into the respective list for display.
     * 
     * @param gui The MainGui object to manipulate
     */
    static void filter(MainGui gui) {
        categoriesList = new ArrayList<String>();
        hashtagList = new ArrayList<String>();
        filteredTask = StorageHandler.getAllTasks();
        filteredTask = hideDeleted(filteredTask);
        populateCategoryAndHashtag();

        if (!currentFilter.isEmpty()) {
            processFilter(currentFilter, gui);
        }

    }

    private static void populateCategoryAndHashtag() {
        for (Task task : hideDeleted(StorageHandler.getAllTasks())) {
            populateHashtag(task);
            populateCategory(task);
        }
    }

    private static void populateCategory(Task task) {

        for (String category : task.getCategories()) {
            if (!categoriesList.contains(category.toLowerCase())) {
                categoriesList.add(category.toLowerCase());
            }
        }

    }

    private static void populateHashtag(Task task) {

        for (String hashtag : task.getHashtags()) {
            if (!hashtagList.contains(hashtag.toLowerCase())) {
                hashtagList.add(hashtag.toLowerCase());
            }
        }

    }

    public static List<Task> getFilteredList() {
        return filteredTask;
    }

    public static List<String> getContextList() {
        return hashtagList;
    }

    public static List<String> getCategoryList() {
        return categoriesList;
    }
}

	// End of segment: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\FilterTasks.java





	/**
	 * origin: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\Logic.java
	 */

package chirptask.logic;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

import org.jnativehook.GlobalScreen;

import chirptask.common.Constants;
import chirptask.common.Settings;
import chirptask.common.Settings.CommandType;
import chirptask.gui.MainGui;
import chirptask.storage.StorageHandler;
import chirptask.storage.Task;

public class Logic {
    private static final String STRING_DONE = "[Done]";

    private GroupAction _lastAction;
    private InputParser _parser = new InputParser();
    private StorageHandler _storageHandler = new StorageHandler();
    private static MainGui _gui;
    private static final int FIRST_ACTION = 0;
    private static final int ZERO = 0;
    private static final int DESCRIPTION_LENGTH = 6;
    private static final int SUB_DESCRIPTION_LEN = 7;

    /**
     * Init of logic which will display all tasks and show user what are the
     * available commands for the program.
     * 
     * @param gui The MainGui object to pass in
     */
    public Logic(MainGui gui) {
        _gui = gui;
        FilterTasks.filter(_gui);
        DisplayView.updateTaskView(_gui);
        DisplayView
                .showStatusToUser(Constants.LOG_MESSAGE_INVALID_COMMAND, _gui);
    }

    /**
     * Refresh the task view and trending list
     */
    private static void clearUi() {
        _gui.clearTrendingList();
        _gui.clearTaskView();
    }

    /**
     * Method for GUI to call to interpret user input and display the command
     * results.
     * 
     * @param input The user's input String
     */
    public void retrieveInputFromUI(String input) {
        _parser.receiveInput(input);
        assert _parser.getActions() != null;

        if (isNotUndoCommand()) {
            setLastGroupAction(_parser.getActions());
        }

        processGroupAction(_parser.getActions().getActionList());
    }

    /**
     * Check whether action receive by inputParser contains undo command.
     * 
     * @return
     */
    private boolean isNotUndoCommand() {
        return _parser.getActions().getActionList().get(FIRST_ACTION)
                .getCommandType() != Settings.CommandType.UNDO;
    }

    /**
     * Execute the list of actions
     * 
     * @param list The List of Action objects to execute
     */
    public void processGroupAction(List<Action> list) {
        for (Action a : list) {
            executeAction(a);
        }
    }

    /**
     * Execute the command given.
     * 
     * @param command The Action object which holds the command
     */
    public void executeAction(Action command) {
        Settings.CommandType actionType = command.getCommandType();
        assert actionType != null;
        Task task = command.getTask();
        interpretCommandAndExecute(command, actionType, task);
    }

    /**
     * Interpret and execute the command.
     * 
     * @param command
     * @param actionType
     * @param task
     */
    private void interpretCommandAndExecute(Action command,
            Settings.CommandType actionType, Task task) {
        switch (actionType) {
        case ADD:
            processAdd(command, task);
            break;
        case DELETE:
            processDelete(command, task);
            break;
        case DISPLAY:
            processDisplay(command, task);
            break;
        case EDIT:
            processEdit(command, task);
            break;
        case UNDO:
            processUndo();
            break;
        case DONE:
            processDone(command, task);
            break;
        case UNDONE:
            processUndone(command, task);
            break;
        case LOGIN:
            processLogin(command);
            break;
        case EXIT:
            processExit();
            break;
        case CLEAR:
            processClear(StorageHandler.getAllTasks());
            break;
        case SYNC:
            processSync(command);
            break;
        case LOGOUT:
            processLogout(command);
            break;
        case INVALID:
            processInvalid(command);
            break;
        default:
            assert false;
        }
    }

    private void processLogout(Action command) {
        assert command != null;
        boolean isSuccess;
        isSuccess = _storageHandler.logout();
        this.showStatusToUser(command, isSuccess);
    }

    private void processSync(Action command) {
        assert command != null;
        boolean isSuccess;
        isSuccess = StorageHandler.sync();
        this.showStatusToUser(command, isSuccess);
    }

    /**
     * Clear out all the done task from the list.
     * 
     * @param list
     */
    private void processClear(List<Task> list) {
        List<Task> clearList = new ArrayList<Task>();
        populateDoneTasks(list, clearList);
        clearDoneTasks(clearList);
    }

    /**
     * Delete the all done tasks from the list
     * 
     * @param clearList
     */
    private void clearDoneTasks(List<Task> clearList) {
        for (int i = ZERO; i < clearList.size(); i++) {
            processDelete(Settings.CommandType.DELETE, clearList.get(i));
        }
    }

    /**
     * 
     * @param list
     * @param clearList
     */
    private void populateDoneTasks(List<Task> list, List<Task> clearList) {
        for (int i = ZERO; i < list.size(); i++) {
            Task currentTask = list.get(i);
            if (currentTask.isDone()) {
                clearList.add(currentTask);
            }
        }
    }

    private void processDelete(CommandType delete, Task t) {
        Task deletedTask;
        boolean isSuccess = false;
        t.setDeleted(true);
        deletedTask = _storageHandler.deleteTask(t);
        if (deletedTask == null) {
            isSuccess = false;
        } else {
            isSuccess = true;

        }
        filterAndDisplay(delete, isSuccess);

    }

    private void filterAndDisplay(CommandType delete, boolean isSuccess) {
        clearUi();
        FilterTasks.filter(_gui);
        showStatusToUser(delete, isSuccess);
        DisplayView.updateTaskView(FilterTasks.getFilteredList(), _gui);
    }

    private void showStatusToUser(CommandType delete, boolean isSuccess) {
        if (isSuccess == true) {
            displaySuccess(delete);
        } else {
            displayError(delete);
        }

    }

    private void displayError(CommandType delete) {
        DisplayView.showStatusToUser(Settings.StatusType.ERROR, delete, _gui);
    }

    private void displaySuccess(CommandType delete) {
        DisplayView.showStatusToUser(Settings.StatusType.MESSAGE, delete, _gui);
    }

    /**
     * Process the invalid actions by user, usage will be display accordingly by
     * the type of command. The wrong command will also be display in the input
     * box for easy editing.
     * 
     * @param command
     */
    private void processInvalid(Action command) {

        Settings.CommandType type = interpreteInvalidCommand(command);
        if (type != Settings.CommandType.INVALID) {
            _gui.setUserInputText(command.getUserInput());
        }
        logErrorCommand();

    }

    private Settings.CommandType interpreteInvalidCommand(Action command) {
        Settings.CommandType type = command.getInvalidCommandType();
        processInvalidTypes(type);
        return type;
    }

    private void processInvalidTypes(Settings.CommandType type) {
        switch (type) {
        case ADD:
            DisplayView.showStatusToUser(Constants.LOG_MESSAGE_ADD_USAGE, _gui,
                    false);
            break;
        case DELETE:
            DisplayView.showStatusToUser(Constants.LOG_MESSAGE_DELETE_USAGE,
                    _gui, false);
            break;
        case DISPLAY:
            DisplayView.showStatusToUser(Constants.LOG_MESSAGE_DISPLAY_USAGE,
                    _gui, false);

            break;
        case EDIT:
            DisplayView.showStatusToUser(Constants.LOG_MESSAGE_EDIT_USAGE, _gui,
                    false);

            break;
        case UNDO:
            // negate action and run excecuteAction again
            DisplayView.showStatusToUser(Constants.LOG_MESSAGE_UNDO_USAGE, _gui,
                    false);

            break;
        case DONE:
            DisplayView.showStatusToUser(Constants.LOG_MESSAGE_DONE_USAGE, _gui,
                    false);

            break;
        case UNDONE:
            DisplayView.showStatusToUser(Constants.LOG_MESSAGE_UNDONE_USAGE,
                    _gui, false);

            break;
        case LOGIN:
            DisplayView.showStatusToUser(Constants.LOG_MESSAGE_LOGIN_USAGE,
                    _gui, false);
            break;
        case CLEAR:
            DisplayView.showStatusToUser(Constants.LOG_MESSAGE_CLEAR_USAGE,
                    _gui, false);

            break;
        case SYNC:
            DisplayView.showStatusToUser(Constants.LOG_MESSAGE_SYNC_USAGE, _gui,
                    false);
            break;
        case LOGOUT:
            DisplayView.showStatusToUser(Constants.LOG_MESSAGE_LOGOUT_USAGE,
                    _gui, false);
            break;
        case INVALID:
            DisplayView.showStatusToUser(Constants.LOG_MESSAGE_INVALID_COMMAND,
                    _gui, false);
            break;
        default:
            assert false;
            break;
        }
    }

    private void logErrorCommand() {
        StorageHandler.logError(String.format(
                Constants.LOG_MESSAGE_INVALID_COMMAND,
                Constants.LOG_MESSAGE_ERROR));
    }

    /**
     * Close all storages/utils and exit the program.
     */
    private void processExit() {
        nativeHookCleanUp();
        _storageHandler.closeStorages();
        systemExit();
    }

    private void systemExit() {
        System.runFinalization();
        System.exit(Settings.SYSTEM_EXIT_NORMAL);
    }

    private void nativeHookCleanUp() {
        if (GlobalScreen.isNativeHookRegistered()) {
            GlobalScreen.unregisterNativeHook();
        }
    }

    private void processLogin(Action command) {
        assert command != null;
        boolean isSuccess;
        isSuccess = StorageHandler.initCloudStorage();
        this.showStatusToUser(command, isSuccess);
    }

    /**
     * Method will mark task as done, and set the done date for task that are
     * floating.
     * 
     * @param command
     * @param task
     */
    private void processDone(Action command, Task task) {
        assert command != null && task != null;
        if (isFloatingTask(task)) {
            Calendar doneDate = Calendar.getInstance();
            task.setDate(doneDate);
        }
        task.setDone(true);
        processEdit(command, task);
    }

    private boolean isFloatingTask(Task task) {
        return Task.TASK_FLOATING.equalsIgnoreCase(task.getType());
    }

    /**
     * Method will mark task as undone, and remove the done date for task that
     * are floating.
     * 
     * @param command
     * @param task
     */
    private void processUndone(Action command, Task task) {
        assert command != null && task != null;
        if (isFloatingTask(task)) {
            task.removeDate();
        }
        task.setDone(false);
        processEdit(command, task);
    }

    /**
     * Process the undo function populate the undo action list, method will the
     * set the list as an lastgroupaction once that is set the method will
     * execute each action as if enter by user.
     * 
     */
    private void processUndo() {
        GroupAction lastAction = getLastGroupAction();
        GroupAction tempGroupAction = new GroupAction();

        if (isLastActionNotNull(lastAction)) {
            populateUndoAction(lastAction, tempGroupAction);
            setLastGroupAction(tempGroupAction);
            lastAction = getLastGroupAction();
            undoGroupAction(lastAction);

        } else {
            DisplayView.showStatusToUser(Constants.LOG_MESSAGE_UNDO_NOTHING,
                    _gui);
        }
    }

    private void populateUndoAction(GroupAction lastAction,
            GroupAction tempGroupAction) {
        for (int i = ZERO; i < lastAction.getActionList().size(); i++) {
            Action action = lastAction.getActionList().get(i);
            populateUndoActionList(tempGroupAction, action);
        }
    }

    private void populateUndoActionList(GroupAction tempGroupAction,
            Action action) {
        if (isUndoActionNotNull(action)) {
            setUndoAndAddToGroupAction(tempGroupAction, action);
        } else {
            DisplayView.showStatusToUser(Constants.LOG_MESSAGE_UNDO_NOTHING,
                    _gui);
        }
    }

    /**
     * Execute the undo actions from the given list.
     * 
     * @param lastAction
     */
    private void undoGroupAction(GroupAction lastAction) {
        for (int i = ZERO; i < lastAction.getActionList().size(); i++) {
            Action action = lastAction.getActionList().get(i);
            executeAction(action);
        }
    }

    /**
     * Set the undo action and set the undo undo action. Meaning user is able to
     * undo only the last action. Eg, add -> undo -> <delete> -> undo -> add
     * 
     * @param tempGroupAction
     * @param action
     */
    private void setUndoAndAddToGroupAction(GroupAction tempGroupAction,
            Action action) {
        Action undoAction = action.undo();
        undoAction.setUndo(action);
        tempGroupAction.addAction(undoAction);
    }

    private boolean isUndoActionNotNull(Action action) {
        return action.undo() != null;
    }

    private boolean isLastActionNotNull(GroupAction lastAction) {
        return lastAction != null;
    }

    /**
     * Method for processing the task for edit. Method will further process
     * googleID task.
     * 
     * @param command
     * @param task
     */
    private void processEdit(Action command, Task task) {
        assert command != null && task != null;
        //processGoogleIdTasks(task);
        boolean isSuccess;
        task.setModified(true);
        isSuccess = _storageHandler.modifyTask(task);
        filterAndDisplay(command, isSuccess);
    }

	// End of segment: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\Logic.java





	/**
	 * origin: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\Logic.java
	 */

    private boolean isUndoneTimedTask(Task task) {
        return Task.TASK_TIMED.equalsIgnoreCase(task.getType())
                && !task.isDone();
    }

    private boolean isDoneTimedTasked(Task task) {
        return Task.TASK_TIMED.equalsIgnoreCase(task.getType())
                && task.isDone();
    }

    private boolean isGoogleIdEmpty(Task task) {
        return task.getGoogleId().isEmpty();
    }

    /**
     * Remove the [Done] from description if task is undone.
     * 
     * @param task
     */
    private void processEditUndone(Task task) {
        if (isValidDescriptionLength(task)) {
            if (containsDoneInDescription(task)) {
                removeDoneDescription(task);
            }
        }
    }

    private void removeDoneDescription(Task task) {
        task.setDescription(task.getDescription().substring(
                SUB_DESCRIPTION_LEN, task.getDescription().length()));
    }

    private boolean containsDoneInDescription(Task task) {
        return task.getDescription().substring(0, DESCRIPTION_LENGTH)
                .equalsIgnoreCase(STRING_DONE);
    }

    private boolean isValidDescriptionLength(Task task) {
        return task.getDescription().length() > DESCRIPTION_LENGTH;
    }

    /**
     * Include done description for task
     * 
     * @param task
     */
    private void processEditDone(Task task) {
        if (isValidDescriptionLength(task)) {
            if (!containsDoneInDescription(task)) {
                includeDoneDescription(task);
            }
        }
    }

    private void includeDoneDescription(Task task) {
        task.setDescription(STRING_DONE + " " + task.getDescription());
    }

    /**
     * Method will refresh UI, refresh tasklist and display filter string on
     * filter bar task list will also be updated according to the filter user
     * enters.
     * 
     * @param command
     * @param task
     */
    private void processDisplay(Action command, Task task) {
        assert task != null;
        clearUi();
        FilterTasks.filter(task, _gui);
        _gui.setFilterText(task.getDescription());
        DisplayView.updateTaskView(FilterTasks.getFilteredList(), _gui);
    }

    private void processDelete(Action command, Task task) {
        assert command != null && task != null;
        Task deletedTask;
        boolean isSuccess;
        task.setDeleted(true);
        deletedTask = _storageHandler.deleteTask(task);
        if (deletedTask == null) {
            isSuccess = false;
        } else {
            isSuccess = true;

        }
        filterAndDisplay(command, isSuccess);
    }

    /**
     * Method will add the task to all storages, this method also process
     * googleId Task and set the deleted flag to false by default.
     * 
     * @param command
     * @param task
     */
    private void processAdd(Action command, Task task) {
        assert command != null && task != null;
        boolean isSuccess = true;

        if (isGoogleIdEmpty(task)) {
            isSuccess = _storageHandler.addTask(task);
        } else {
            task.setDeleted(false);
            _storageHandler.modifyTask(task);
        }

        filterAndDisplay(command, isSuccess);
    }

    /**
     * Method for google syncing to refresh the tasklist when it has
     * successfully sync the tasks.
     */
    public synchronized void refreshUi() {
        if (_gui != null) {
            clearUi();
            FilterTasks.filter(_gui);
            DisplayView.updateTaskView(FilterTasks.getFilteredList(), _gui);
        }
    }

    public synchronized static void refresh() {
        _gui.refreshUI();
    }

    private void filterAndDisplay(Action command, boolean isSuccess) {
        assert command != null;
        clearUi();
        FilterTasks.filter(_gui);
        DisplayView.updateTaskView(FilterTasks.getFilteredList(), _gui);
        showStatusToUser(command, isSuccess);
    }

    private void showStatusToUser(Action command, boolean isSuccess) {
        assert command != null;
        if (isSuccess == true) {
            DisplayView.showStatusToUser(Settings.StatusType.MESSAGE, command,
                    _gui);
        } else {
            DisplayView.showStatusToUser(Settings.StatusType.ERROR, command,
                    _gui);
        }
    }

    /**
     * Method for Google component to call when sync is successful
     * 
     * @param status The status string to set on the GUI
     */
    public static void setOnlineStatus(String status) {
        if (status != null && _gui != null) {
            _gui.setOnlineStatus(status);
        }
    }

    public GroupAction getLastGroupAction() {
        return _lastAction;
    }

    public void setLastGroupAction(GroupAction lastAction) {
        this._lastAction = lastAction;
    }
    
    
    /**
     * Call this method for JUnit Tests to get a fresh local storage each run
     * This method also ensure that the FilteredList and DisplayView 
     * are updated with the tasks from JUnit Test XML.
     */
    public void useTestLocalStorage() {
        _storageHandler.setUpJUnitTestXmlWriter();
        FilterTasks.filter(_gui);
        DisplayView.updateTaskView(_gui);
    }

}

	// End of segment: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\logic\Logic.java





	/**
	 * origin: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\storage\Task.java
	 */

    public void setDate(Calendar doneDate) {
        if (doneDate == null) {
            throw new NullPointerException();
        }
        _cal = doneDate;
        _cal.set(Calendar.HOUR_OF_DAY, 0);
        _cal.set(Calendar.MINUTE, 0);
        _cal.set(Calendar.SECOND, 0);
        _cal.set(Calendar.MILLISECOND, 0);
    }

}

	// End of segment: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\storage\Task.java





	/**
	 * origin: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\testing\JUnitLogicAtd.java
	 */

public class JUnitLogicAtd {

    @Test
    public void commandtest() {
        // Integration testing with UI and storage
        MainGui2 _mainGui = new MainGui2();
        Logic _logic = new Logic(_mainGui);
        _logic.useTestLocalStorage();

        // Adding a normal floating task
        _logic.retrieveInputFromUI("add normal floating task");
        // Compare task list if task is there means successfully added to local
        // storage
        assertEquals(FilterTasks.getFilteredList().get(0).getDescription(),
                "normal floating task");

        // Delete that task
        _logic.retrieveInputFromUI("delete 1");
        assertEquals(FilterTasks.getFilteredList().size(), 0);

        // adding a timed task
        _logic.retrieveInputFromUI("addt eating with mum from 12a to 12p 08/11");
        assertEquals(FilterTasks.getFilteredList().get(0).getDescription(),
                "eating with mum");

        // add deadline task
        _logic.retrieveInputFromUI("addd go out with parents on 17/11");
        assertEquals(FilterTasks.getFilteredList().get(1).getDescription(),
                "go out with parents by 23:59");
        
        // Use a invalid command 
        // Expected task to be in the list 2, since this is a wrong type
        _logic.retrieveInputFromUI("adddd go out on 17/11");
        assertEquals(FilterTasks.getFilteredList().size(), 2);

        // delete all task
        _logic.retrieveInputFromUI("delete 1-2");
        assertEquals(FilterTasks.getFilteredList().size(), 0);

        // Undo command
        _logic.retrieveInputFromUI("undo");
        assertEquals(FilterTasks.getFilteredList().size(), 2);

        // Undo again
        _logic.retrieveInputFromUI("undo");
        assertEquals(FilterTasks.getFilteredList().size(), 0);

        // Undo the tasks again this time task will be added back
        _logic.retrieveInputFromUI("undo");
        assertEquals(FilterTasks.getFilteredList().size(), 2);

        // edit task 1 change desc to dad
        _logic.retrieveInputFromUI("edit 1 eating with dad from 12a to 12p 08/11");
        assertEquals(FilterTasks.getFilteredList().get(0).getDescription(),
                "eating with dad");
        
        // Delete out of range tasks
        // This action will not be execute as it delete tasks that are out of range
        _logic.retrieveInputFromUI("delete 1-3");
        assertEquals(FilterTasks.getFilteredList().size(), 2);
        
        //Done a task
        //Task 1 is done, expected true
        _logic.retrieveInputFromUI("done 1");
        assertEquals(FilterTasks.getFilteredList().get(0).isDone(), true);
        //Undone a task
        //Task 1 is undone, expected false
        _logic.retrieveInputFromUI("undone 1");
        assertEquals(FilterTasks.getFilteredList().get(0).isDone(), false);
        //Done a task out of range
        //Expect none of the tasks to be done since its out of range.
        _logic.retrieveInputFromUI("done 1-3");
        assertEquals(FilterTasks.getFilteredList().get(0).isDone(), false);
        assertEquals(FilterTasks.getFilteredList().get(1).isDone(), false);
        //Undone a task out of range
        //Expect all task to be remain as done none of the task will be undone.
        _logic.retrieveInputFromUI("done 1-2");
        _logic.retrieveInputFromUI("undone 1-3");
        assertEquals(FilterTasks.getFilteredList().get(0).isDone(), true);
        assertEquals(FilterTasks.getFilteredList().get(1).isDone(), true);
        //Delete all task
        //Expect list to be empty
        _logic.retrieveInputFromUI("delete 1-2");
        assertEquals(FilterTasks.getFilteredList().size(), 0);
    }

    @Test
    public void DisplayViewTest() {

        // Test method convertTaskDateToString

        // test floating task
        Task test1 = new Task();
        test1.setType("floating");
        assertEquals("", DisplayView.convertTaskDateToDurationString(test1));

        // test Deadline task
        Calendar date = Calendar.getInstance();
        date.set(2014, 9, 22);
        date.set(Calendar.HOUR_OF_DAY, 23);
        date.set(Calendar.MINUTE, 59);
        Task test2 = new DeadlineTask(1, "test", date);
        assertEquals("due by 23:59",
                DisplayView.convertTaskDateToDurationString(test2));

        // test timedtask
        Calendar startTime = Calendar.getInstance();
        Calendar endTime = Calendar.getInstance();
        startTime.set(2014, 9, 22, 12, 0);
        endTime.set(2014, 9, 22, 14, 0);
        Task timed = new TimedTask(2, "test2", startTime, endTime);
        assertEquals("12:00 to 14:00",
                DisplayView.convertTaskDateToDurationString(timed));

        // Boundary -- test a type of task that is not the 3 type
        // this should crash the program as this will never happen
        Task troll = new Task();
        troll.setType("troll");
        // DisplayView.convertTaskDateToString(troll);

    }

    @Test
    public void testFilterTasks() {
        // test Method hideDeleted

        // Create a list of all deleted task
        // hideDeleted should return an empty list
        List<Task> list = new ArrayList<Task>();
        List<Task> expected = new ArrayList<Task>();
        Task A = new Task();
        Task B = new Task();
        Task C = new Task();
        A.setDeleted(true);
        B.setDeleted(true);
        C.setDeleted(true);

        list.add(A);
        list.add(B);
        list.add(C);

        list = FilterTasks.hideDeleted(list);
        assertEquals(expected, list);

        // Set B to be deleted
        // hideDeleted should return a list with Task B
        B.setDeleted(false);
        list.add(A);
        list.add(B);
        list.add(C);
        expected.add(B);

        list = FilterTasks.hideDeleted(list);
        assertEquals(expected, list);

        // setDeleted false for all Tasks
        // should return a list of all task
        A.setDeleted(false);
        C.setDeleted(false);
        list.add(A);
        list.add(C);
        expected.add(A);
        expected.add(C);

        list = FilterTasks.hideDeleted(list);
        assertEquals(expected, list);
        // End of test for hideDeleted

        // test for method processFilterDateParam

        // proper date format DD/MM
        String date1 = "22/10";
        Calendar testParam = Calendar.getInstance();
        testParam.set(testParam.get(Calendar.YEAR), 9, 22);

        Calendar expected1 = null;
        try {
            expected1 = FilterTasks.processFilterDateParam(date1);
        } catch (InvalidParameterException invalidParameterException) {

        }

        assertNotNull(expected1);
        assertEquals(testParam.get(Calendar.YEAR), expected1.get(Calendar.YEAR));
        assertEquals(testParam.get(Calendar.MONTH),
                expected1.get(Calendar.MONTH));
        assertEquals(testParam.get(Calendar.DAY_OF_MONTH),
                expected1.get(Calendar.DAY_OF_MONTH));

        // wrong date format MM-DD
        // Return a current Calendar object
        String date2 = "10-22";
        Calendar expected2 = null;
        try {
            expected2 = FilterTasks.processFilterDateParam(date2);
        } catch (InvalidParameterException invalidParameterException) {
            assertNotNull(invalidParameterException);
        }

        assertNull(expected2);
        // End of test for processFilterDateParam
    }

}

	// End of segment: C:\Users\User\Dropbox\MYNUS\Year 2\Sem1\CS2103T\Assignment\Project\main\src\chirptask\testing\JUnitLogicAtd.java





